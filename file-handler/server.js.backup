// =============================================================================
// FILE-HANDLER API - server.js
// =============================================================================
// This is the main backend server for the Music Agent MVP.
// It handles file uploads, metadata storage, and release management.
//
// How to run:   cd ~/Documents/music-agent-mvp/file-handler && node server.js
// Runs on:      http://localhost:3001
// Health check: curl http://localhost:3001/health
// =============================================================================


// =============================================================================
// SECTION 1: IMPORTS (Loading the tools we need)
// =============================================================================
// Think of these like hiring specialists for different jobs.
// Each package does one specific thing well.

const express = require('express');          // The web server framework - handles HTTP requests/responses
const multer = require('multer');            // File upload handler - processes multipart/form-data
const cors = require('cors');                // Cross-Origin Resource Sharing - allows n8n/Next.js to call our API
const path = require('path');                // File path utilities - joins folder paths safely across OS types
const fs = require('fs').promises;           // File system (async version) - read/write files without blocking
const fsSync = require('fs');                // File system (sync version) - for Multer callbacks that need instant results
const checkDiskSpace = require('check-disk-space').default;  // Monitors how much disk space is left
const musicMetadata = require('music-metadata');             // Reads audio file info (duration, bitrate, codec)
const archiver = require('archiver');                // ZIP file creator - packages files for distribution

// =============================================================================
// SECTION 2: SERVER CONFIGURATION
// =============================================================================
// Basic setup: create the server, set the port, enable middleware.

const app = express();   // Create the Express application (this IS our server)
const PORT = 3001;       // The port number our server listens on

// --- Middleware ---
// Middleware runs on EVERY request before it reaches your routes.
// Think of it like a security checkpoint at an airport - every request passes through.

app.use(cors());           // Allow requests from other origins (n8n on port 5678, Next.js on port 3000)
app.use(express.json());   // Parse JSON request bodies (needed for POST /metadata endpoint)


// =============================================================================
// SECTION 3: CONSTANTS
// =============================================================================
// The base folder where ALL release files are stored on your Mac.
// Every release gets its own subfolder inside this directory.

const RELEASES_BASE = '/Users/Mathias2/Documents/Music Agent/Releases';


// =============================================================================
// SECTION 4: HELPER FUNCTIONS
// =============================================================================
// These are reusable tools that our routes call upon.
// Keeping them separate makes the code cleaner and easier to maintain.

// --- 4a: requireReleaseId ---
// Extracts and validates the releaseId from the URL query string or URL params.
// Example URL: /upload?releaseId=2026-02-05_SophieJoe_TellMe
// Example URL: /releases/2026-02-05_SophieJoe_TellMe/versions
// This function grabs the releaseId from either source.
// Throws an error if no releaseId is provided.

function requireReleaseId(req) {
  // Check URL params first (for /releases/:releaseId/versions)
  // Then fall back to query params (for /upload?releaseId=...)
  const releaseId = (req.params?.releaseId || req.query.releaseId || '').trim();
  
  if (!releaseId) {
    const err = new Error('Missing releaseId. Use /upload?releaseId=YOUR_RELEASE_ID or /releases/:releaseId/...');
    err.statusCode = 400;  // 400 = Bad Request (client sent something wrong)
    throw err;
  }
  return releaseId;
}


// --- 4b: classify ---
// Determines what TYPE of file was uploaded (audio, artwork, or video).
// This decides which subfolder the file goes into.
// Strategy: Check mimetype first (more reliable), fall back to file extension.
//
// Example: An MP3 file has mimetype "audio/mpeg" â†’ goes to audio/ folder
// Example: A PNG file has mimetype "image/png"  â†’ goes to artwork/ folder

function classify(file) {
  // First try: check the mimetype (the browser/sender tells us what type it is)
  if (file.mimetype?.startsWith('audio/')) return 'audio';
  if (file.mimetype?.startsWith('image/')) return 'artwork';
  if (file.mimetype?.startsWith('video/')) return 'video';
  
  // Fallback: check the file extension (in case mimetype is missing or wrong)
  const ext = path.extname(file.originalname).toLowerCase();
  if (['.wav', '.mp3', '.flac', '.aiff', '.m4a', '.ogg'].includes(ext)) return 'audio';
  if (['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp'].includes(ext)) return 'artwork';
  if (['.mp4', '.mov', '.avi', '.mkv', '.webm'].includes(ext)) return 'video';
  
  return 'other';  // Unknown file type
}


// --- 4c: validateAudioFile ---
// Checks if an audio file is valid and not corrupt.
// Uses the music-metadata package to read the file's internal data.
// Returns either { valid: true, metadata: {...} } or { valid: false, error: "..." }
//
// What it checks:
// - Can the file be read at all? (not corrupt)
// - Does it have a duration? (real audio file)
// - Is duration between 1 second and 1 hour? (reasonable for a music track)

async function validateAudioFile(filePath) {
  try {
    const metadata = await musicMetadata.parseFile(filePath);
    
    // Check 1: Can we read basic format info?
    if (!metadata.format || !metadata.format.duration) {
      return {
        valid: false,
        error: 'Could not read audio metadata - file may be corrupt'
      };
    }
    
    // Check 2: Is the duration reasonable? (between 1 second and 1 hour)
    if (metadata.format.duration <= 0 || metadata.format.duration > 3600) {
      return {
        valid: false,
        error: `Invalid audio duration: ${metadata.format.duration}s (expected 1s - 1 hour)`
      };
    }
    
    // All checks passed! Return the metadata we extracted.
    return {
      valid: true,
      metadata: {
        duration: Math.round(metadata.format.duration),  // Duration in seconds
        bitrate: metadata.format.bitrate,                 // Quality indicator (e.g., 1411200 for WAV)
        sampleRate: metadata.format.sampleRate,           // e.g., 44100 Hz
        channels: metadata.format.numberOfChannels,       // 1 = mono, 2 = stereo
        codec: metadata.format.codec                      // e.g., "PCM" for WAV, "MPEG" for MP3
      }
    };
    
  } catch (error) {
    return {
      valid: false,
      error: `Audio validation failed: ${error.message}`
    };
  }
}

// --- 4d: generateVersionId ---
// Converts a version name into a URL-safe folder name.
// Example: "Extended Mix" â†’ "extended-mix"
// Example: "Radio Edit" â†’ "radio-edit"
// Example: "Primary Version" â†’ "primary"
//
// Why we need this:
// - Folder names can't have spaces (causes issues in terminal commands)
// - Lowercase makes everything consistent
// - Hyphens are safer than underscores for cross-platform compatibility

function generateVersionId(versionName) {
  if (!versionName || versionName.trim() === '') {
    return 'primary';  // Default fallback
  }
  
  // Special case: "Primary Version" should return "primary"
  if (versionName.trim().toLowerCase() === 'primary version') {
    return 'primary';
  }
  
  return versionName
    .toLowerCase()                    // "Extended Mix" â†’ "extended mix"
    .replace(/\s+/g, '-')             // "extended mix" â†’ "extended-mix"
    .replace(/[^a-z0-9-]/g, '')       // Remove any special characters
    .replace(/-+/g, '-')              // Replace multiple hyphens with single
    .replace(/^-|-$/g, '');           // Remove leading/trailing hyphens
}


// --- 4e: getVersionInfo ---
// Extracts version information from the request.
// Returns an object with versionName and versionId.
// If no versionName is provided, defaults to "Primary Version".
//
// This centralizes version logic so we don't repeat it everywhere.

function getVersionInfo(req) {
  const versionName = (req.query.versionName || '').trim() || 'Primary Version';
  const versionId = generateVersionId(versionName);
  
  return {
    versionName,
    versionId,
    isPrimary: versionId === 'primary'
  };
}

// =============================================================================
// SECTION 5: MULTER CONFIGURATION (File Upload Settings)
// =============================================================================
// Multer handles the actual file saving when someone uploads files.
// This configuration tells Multer WHERE to save files and WHAT to name them.
//
// How it works:
// 1. A request comes in with files attached
// 2. Multer calls destination() to decide the folder path
// 3. Multer calls filename() to decide the file name
// 4. Multer saves the file to disk
// 5. THEN your route handler runs with req.files populated

const storage = multer.diskStorage({
  // WHERE to save each file
  // NEW structure: Releases/<releaseId>/versions/<versionId>/audio/ (for audio files)
  //                Releases/<releaseId>/artwork/ (for artwork - shared by all versions)
  //                Releases/<releaseId>/video/ (for video - shared by all versions)
  destination: function (req, file, cb) {
    try {
      const releaseId = requireReleaseId(req);
      const subfolder = classify(file);  // "audio", "artwork", or "video"
      
      let fullPath;
      
      if (subfolder === 'audio') {
        // Audio files go into version-specific folders
        const versionInfo = getVersionInfo(req);
        fullPath = path.join(RELEASES_BASE, releaseId, 'versions', versionInfo.versionId, 'audio');
        console.log(`ðŸ“ Creating audio path for version "${versionInfo.versionName}": ${versionInfo.versionId}/audio/`);
      } else {
        // Artwork and video are shared by all versions (no version subfolder)
        fullPath = path.join(RELEASES_BASE, releaseId, subfolder);
        console.log(`ðŸ“ Creating shared asset path: ${subfolder}/`);
      }
      
      fsSync.mkdirSync(fullPath, { recursive: true });  // Create folders if they don't exist
      cb(null, fullPath);  // Tell Multer to save here
    } catch (e) {
      cb(e);  // Pass error to Multer
    }
  },
  // WHAT to name each file (keep original filename)
  filename: function (req, file, cb) {
    cb(null, file.originalname);
  }
});

// Create the upload middleware using our storage configuration
// .any() means accept files from ANY form field name
const upload = multer({ storage });


// =============================================================================
// SECTION 6: API ROUTES
// =============================================================================
// These are the endpoints that handle incoming requests.
// Each route has: HTTP method (GET/POST), URL path, and handler function.
//
// Current routes:
//   GET  /health          â†’ Server status check
//   POST /upload          â†’ Upload files for a release (with duplicate detection + audio validation)
//   POST /metadata        â†’ Save metadata.json for a release
//   GET  /releases        â†’ List all releases (sorted newest first)
//   GET  /storage/status  â†’ Check disk space
//
// Milestone 5 routes:
//   GET  /releases/:releaseId              â†’ Get one specific release
//   POST /releases/:releaseId/versions     â†’ Add version to existing release
//   PATCH /releases/:releaseId/distribution â†’ Update distribution tracking


// --- 6a: Health Check ---
// Simple endpoint to verify the server is running.
// Used by: startup verification, n8n connection tests

app.get('/health', (req, res) => {
  res.json({ status: 'ok', message: 'File handler is running' });
});


// --- 6b: File Upload ---
// Receives files from n8n Form Trigger (or REST Client for testing).
// This route has TWO middleware functions chained together:
//   1. First function: checks for duplicates BEFORE uploading
//   2. upload.any(): Multer saves the files to disk
//   3. Second function (async): validates audio files AFTER saving
//
// URL format: POST /upload?releaseId=...&artist=...&title=...&genre=...
// The query parameters are passed through from n8n so metadata can reference them.

app.post('/upload', (req, res, next) => {
  // --- STEP 1: Duplicate Detection (runs BEFORE file upload) ---
  const releaseId = req.query.releaseId;
  
  if (!releaseId) {
    return res.status(400).json({
      success: false,
      error: 'Missing releaseId parameter'
    });
  }
  
  const releasePath = path.join(RELEASES_BASE, releaseId);
  
  // Check if a folder with this releaseId already exists
  if (fsSync.existsSync(releasePath)) {
    console.log(`ðŸš« Duplicate upload attempt blocked: ${releaseId} already exists`);
    return res.status(409).json({  // 409 = Conflict (resource already exists)
      success: false,
      error: 'Duplicate release detected',
      message: `Release "${releaseId}" already exists. Use a different release name or delete the existing release first.`,
      existingPath: releasePath
    });
  }
  
  next();  // No duplicate found â†’ continue to Multer upload
  
}, upload.any(), async (req, res) => {
  // --- STEP 2: Post-Upload Processing (runs AFTER files are saved) ---
  const releaseId = req.query.releaseId;
  const artist = req.query.artist;
  const title = req.query.title;
  const genre = req.query.genre;
  
  console.log(`ðŸ“¥ Upload received: ${req.files?.length || 0} files for ${releaseId}`);
  
  // --- STEP 3: Audio Validation ---
  // Find all audio files that were uploaded and validate each one
  const audioFiles = req.files?.filter(f => classify(f) === 'audio') || [];
  const validationResults = [];
  
  for (const audioFile of audioFiles) {
    console.log(`ðŸŽµ Validating audio: ${audioFile.originalname}...`);
    const validation = await validateAudioFile(audioFile.path);
    
    if (!validation.valid) {
      console.error(`âŒ Audio validation failed: ${audioFile.originalname}`);
      console.error(`   Error: ${validation.error}`);
      
      // Delete the invalid file (it was already saved by Multer)
      fsSync.unlinkSync(audioFile.path);
      
      return res.status(422).json({  // 422 = Unprocessable Entity (file is invalid)
        success: false,
        error: 'Audio file validation failed',
        file: audioFile.originalname,
        reason: validation.error
      });
    }
    
    console.log(`âœ… Audio valid: ${audioFile.originalname} (${validation.metadata.duration}s, ${validation.metadata.codec})`);
    validationResults.push({
      file: audioFile.originalname,
      ...validation.metadata
    });
  }
  
  // Log where each file was saved
  req.files?.forEach(f => {
    console.log(`   â†’ ${f.originalname} saved to ${path.basename(path.dirname(f.path))}/ folder`);
  });

  // --- STEP 4: Send Success Response ---
  // Returns all file info + query params + version info so n8n can generate proper metadata
  const versionInfo = getVersionInfo(req);
  
  res.json({
    success: true,
    releaseId,
    artist,
    title,
    genre,
    versionInfo: {
      versionName: versionInfo.versionName,
      versionId: versionInfo.versionId,
      isPrimary: versionInfo.isPrimary
    },
    filesUploaded: (req.files || []).map(f => ({
      originalName: f.originalname,
      savedTo: f.path,
      size: f.size,
      mimetype: f.mimetype,
      category: classify(f)  // Added: tells n8n if this is audio/artwork/video
    })),
    audioValidation: validationResults
  });
});


// --- 6c: Save Metadata ---
// Receives a JSON body with releaseId + metadata object, saves as metadata.json.
// Called by: n8n "Save Metadata" HTTP Request node after upload.
//
// Expected body: { "releaseId": "2026-02-05_...", "metadata": { artist, title, genre, ... } }

app.post('/metadata', (req, res) => {
  const { releaseId, metadata } = req.body;
  
  if (!releaseId || !metadata) {
    return res.status(400).json({ 
      success: false, 
      error: 'Missing releaseId or metadata' 
    });
  }
  
  const releasePath = path.join(RELEASES_BASE, releaseId);
  const metadataPath = path.join(releasePath, 'metadata.json');
  
  try {
    // Create the release folder if it doesn't exist yet
    if (!fsSync.existsSync(releasePath)) {
      fsSync.mkdirSync(releasePath, { recursive: true });
    }
    
    // Write metadata as formatted JSON (null, 2 = pretty-print with 2-space indent)
    fsSync.writeFileSync(metadataPath, JSON.stringify(metadata, null, 2));
    
    res.json({ 
      success: true, 
      message: 'Metadata saved successfully',
      path: metadataPath 
    });
  } catch (error) {
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});


// --- 6d: List All Releases ---
// Scans the Releases folder, reads each release's metadata.json,
// and returns them all sorted by creation date (newest first).
// Called by: Future dashboard UI, testing via REST Client

app.get('/releases', async (req, res) => {
  try {
    // Read all items in the Releases folder
    const releasesFolders = await fs.readdir(RELEASES_BASE, { withFileTypes: true });
    // Filter to only directories (ignore stray files)
    const releaseDirs = releasesFolders.filter(item => item.isDirectory());
    const releases = [];
    
    // Read metadata.json from each release folder
    for (const dir of releaseDirs) {
      const releaseId = dir.name;
      const metadataPath = path.join(RELEASES_BASE, releaseId, 'metadata.json');
      
      try {
        const metadataContent = await fs.readFile(metadataPath, 'utf8');
        const metadata = JSON.parse(metadataContent);
        releases.push(metadata);
      } catch (error) {
        // If a folder has no metadata.json, warn but don't crash
        console.warn(`âš ï¸  Warning: Could not read metadata for ${releaseId}:`, error.message);
      }
    }
    
    // Sort: newest releases first (by createdAt timestamp)
    releases.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
    
    console.log(`ðŸ“‚ Listed ${releases.length} release(s)`);
    
    res.json({
      count: releases.length,
      releases: releases
    });
    
  } catch (error) {
    console.error('âŒ Error listing releases:', error);
    res.status(500).json({ error: 'Failed to list releases' });
  }
});


// =============================================================================
// MILESTONE 5 ROUTES
// =============================================================================

// --- 6e: Get Single Release ---
// Returns the full metadata for one specific release.
// Uses a URL parameter (:releaseId) instead of a query string (?releaseId=...).
// Example: GET /releases/2026-02-05_SophieJoe_TellMe

app.get('/releases/:releaseId', async (req, res) => {
  try {
    const releaseId = req.params.releaseId;
    const releasePath = path.join(RELEASES_BASE, releaseId);
    const metadataPath = path.join(releasePath, 'metadata.json');

    // Check if the release folder exists
    try {
      await fs.access(releasePath);
    } catch {
      console.log(`ðŸ” Release not found: ${releaseId}`);
      return res.status(404).json({
        success: false,
        error: 'Release not found',
        message: `No release found with ID "${releaseId}"`
      });
    }

    // Read and return the metadata
    const metadataContent = await fs.readFile(metadataPath, 'utf8');
    const metadata = JSON.parse(metadataContent);

    console.log(`ðŸ” Found release: ${releaseId}`);

    res.json({
      success: true,
      release: metadata
    });

  } catch (error) {
    console.error(`âŒ Error fetching release ${req.params.releaseId}:`, error.message);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch release details'
    });
  }
});


// --- 6f: Update Distribution Tracking ---
// Adds or updates a distribution entry in a release's metadata.json.
// This is how the system tracks "where has this track been sent?"
//
// Uses PATCH because we're updating PART of an existing resource (not creating new).
// URL format: PATCH /releases/:releaseId/distribution

app.patch('/releases/:releaseId/distribution', async (req, res) => {
  try {
    const releaseId = req.params.releaseId;
    const { path: distPath, entry } = req.body;

    // --- Validation ---

    if (!distPath || !entry) {
      return res.status(400).json({
        success: false,
        error: 'Missing required fields',
        message: 'Request body must include "path" (publish/labels/streaming/marketing) and "entry" (object with platform details)'
      });
    }

    const validPaths = ['publish', 'labels', 'streaming', 'marketing'];
    if (!validPaths.includes(distPath)) {
      return res.status(400).json({
        success: false,
        error: 'Invalid distribution path',
        message: `"${distPath}" is not valid. Use one of: ${validPaths.join(', ')}`
      });
    }

    if (!entry.platform) {
      return res.status(400).json({
        success: false,
        error: 'Missing platform',
        message: 'The entry object must include a "platform" field (e.g., "YouTube", "SoundCloud", "DistroKid")'
      });
    }

    // --- Read existing metadata ---
    const releasePath = path.join(RELEASES_BASE, releaseId);
    const metadataPath = path.join(releasePath, 'metadata.json');

    try {
      await fs.access(releasePath);
    } catch {
      return res.status(404).json({
        success: false,
        error: 'Release not found',
        message: `No release found with ID "${releaseId}"`
      });
    }

    const metadataContent = await fs.readFile(metadataPath, 'utf8');
    const metadata = JSON.parse(metadataContent);

    // --- Update the distribution section ---

    if (!metadata.distribution) {
      metadata.distribution = {};
    }

    if (!metadata.distribution[distPath]) {
      metadata.distribution[distPath] = [];
    }

    entry.updatedAt = new Date().toISOString();

    const existingIndex = metadata.distribution[distPath].findIndex(
      e => e.platform === entry.platform
    );

    if (existingIndex >= 0) {
      metadata.distribution[distPath][existingIndex] = {
        ...metadata.distribution[distPath][existingIndex],
        ...entry
      };
      console.log(`ðŸ“¦ Updated ${entry.platform} in ${distPath} for ${releaseId}`);
    } else {
      metadata.distribution[distPath].push(entry);
      console.log(`ðŸ“¦ Added ${entry.platform} to ${distPath} for ${releaseId}`);
    }

    // --- Save the updated metadata ---
    await fs.writeFile(metadataPath, JSON.stringify(metadata, null, 2));

    res.json({
      success: true,
      message: existingIndex >= 0
        ? `Updated ${entry.platform} in ${distPath}`
        : `Added ${entry.platform} to ${distPath}`,
      distribution: metadata.distribution
    });

  } catch (error) {
    console.error(`âŒ Error updating distribution for ${req.params.releaseId}:`, error.message);
    res.status(500).json({
      success: false,
      error: 'Failed to update distribution tracking'
    });
  }
});


// --- 6g: Add Version to Existing Release ---
// Adds a new audio version to an existing release.
// The release must already exist (created via POST /upload).
// This allows adding "Radio Edit", "Instrumental", etc. to releases over time.
//
// URL format: POST /releases/:releaseId/versions?versionName=Extended%20Mix
// Body: multipart/form-data with audioFile
//
// How the 3 middleware functions work together:
//   1. First function: checks if release exists BEFORE uploading
//   2. upload.any(): Multer saves the uploaded file(s) to disk
//   3. Third function (async): validates audio, moves file, sends response

app.post('/releases/:releaseId/versions',

  // --- Middleware 1: Check if release exists BEFORE Multer runs ---
  (req, res, next) => {
    const releaseId = req.params.releaseId;
    const releasePath = path.join(RELEASES_BASE, releaseId);

    if (!fsSync.existsSync(releasePath)) {
      console.log(`ðŸ” Release not found: ${releaseId}`);
      return res.status(404).json({
        success: false,
        error: 'Release not found',
        message: `No release found with ID "${releaseId}". Create the release first with POST /upload`
      });
    }

    // Check if versionName was provided
    const versionName = (req.query.versionName || '').trim();
    if (!versionName) {
      return res.status(400).json({
        success: false,
        error: 'Missing versionName',
        message: 'Add ?versionName=YourVersionName to the URL (e.g., ?versionName=Extended%20Mix)'
      });
    }

    // Check if this version already exists
    const versionId = generateVersionId(versionName);
    const versionPath = path.join(releasePath, 'versions', versionId);

    if (fsSync.existsSync(versionPath)) {
      console.log(`ðŸš« Version already exists: ${versionId} in ${releaseId}`);
      return res.status(409).json({
        success: false,
        error: 'Version already exists',
        message: `Version "${versionName}" (${versionId}) already exists for release "${releaseId}"`
      });
    }

    next();  // Release exists, version is new â†’ continue to Multer upload
  },

  // --- Middleware 2: Multer saves the uploaded file to disk ---
  upload.any(),

  // --- Middleware 3: Validate audio and send response ---
  async (req, res) => {
    try {
      const releaseId = req.params.releaseId;
      const releasePath = path.join(RELEASES_BASE, releaseId);
      const versionInfo = getVersionInfo(req);
      const versionName = versionInfo.versionName;
      const versionId = versionInfo.versionId;
      const versionPath = path.join(releasePath, 'versions', versionId);

      // --- STEP 1: Check that audio files were uploaded ---
      const audioFiles = (req.files || []).filter(f => classify(f) === 'audio');

      if (audioFiles.length === 0) {
        return res.status(400).json({
          success: false,
          error: 'No audio file uploaded',
          message: 'You must upload at least one audio file for the new version'
        });
      }

      // --- STEP 2: Audio validation ---
      const audioFile = audioFiles[0];

      console.log(`ðŸŽµ Validating audio for new version "${versionName}": ${audioFile.originalname}...`);

      const validation = await validateAudioFile(audioFile.path);

      if (!validation.valid) {
        console.error(`âŒ Audio validation failed: ${audioFile.originalname}`);
        console.error(`   Error: ${validation.error}`);

        // Delete the invalid file (Multer already saved it)
        try {
          fsSync.unlinkSync(audioFile.path);
          // Try to clean up empty directories
          const audioDir = path.dirname(audioFile.path);
          fsSync.rmdirSync(audioDir);
          fsSync.rmdirSync(versionPath);
        } catch (cleanupErr) {
          // Cleanup is best-effort, don't crash if folders aren't empty
          console.warn(`âš ï¸  Cleanup note: ${cleanupErr.message}`);
        }

        return res.status(422).json({
          success: false,
          error: 'Audio file validation failed',
          file: audioFile.originalname,
          reason: validation.error
        });
      }

      console.log(`âœ… Audio valid: ${audioFile.originalname} (${validation.metadata.duration}s, ${validation.metadata.codec})`);
      console.log(`ðŸ“¦ Added version "${versionName}" (${versionId}) to ${releaseId}`);

      // --- STEP 3: Success response ---
      res.json({
        success: true,
        message: `Version "${versionName}" added successfully`,
        releaseId,
        versionInfo: {
          versionName,
          versionId,
          isPrimary: versionId === 'primary'
        },
        audioFile: {
          originalName: audioFile.originalname,
          savedTo: audioFile.path,
          size: audioFile.size,
          mimetype: audioFile.mimetype
        },
        audioValidation: {
          file: audioFile.originalname,
          ...validation.metadata
        }
      });

    } catch (error) {
      console.error(`âŒ Error adding version to ${req.params.releaseId}:`, error.message);
      res.status(500).json({
        success: false,
        error: 'Failed to add version',
        details: error.message
      });
    }
  }
);
// --- 6i: Generate SoundCloud Package ---
// Creates a distribution-ready ZIP package for manual SoundCloud upload.
// The ZIP contains: audio file, artwork, and formatted metadata text file.
//
// URL format: POST /distribute/soundcloud/package
// Body (JSON): { "releaseId": "...", "versionId": "...", "privacy": "public|private" }

app.post('/distribute/soundcloud/package', async (req, res) => {
  try {
    const { releaseId, versionId, privacy } = req.body;

    // --- STEP 1: Validate inputs ---
    
    if (!releaseId) {
      return res.status(400).json({
        success: false,
        error: 'Missing releaseId',
        message: 'Request body must include "releaseId"'
      });
    }

    if (!versionId) {
      return res.status(400).json({
        success: false,
        error: 'Missing versionId',
        message: 'Request body must include "versionId" (e.g., "primary", "extended-mix")'
      });
    }

    if (!privacy || !['public', 'private'].includes(privacy)) {
      return res.status(400).json({
        success: false,
        error: 'Invalid privacy setting',
        message: 'Privacy must be either "public" or "private"'
      });
    }

    console.log(`ðŸ“¦ Generating SoundCloud package for ${releaseId} (${versionId})`);

    // --- STEP 2: Check if release exists and read metadata ---
    
    const releasePath = path.join(RELEASES_BASE, releaseId);
    const metadataPath = path.join(releasePath, 'metadata.json');

    try {
      await fs.access(releasePath);
    } catch {
      return res.status(404).json({
        success: false,
        error: 'Release not found',
        message: `No release found with ID "${releaseId}"`
      });
    }

    const metadataContent = await fs.readFile(metadataPath, 'utf8');
    const metadata = JSON.parse(metadataContent);

    // --- STEP 3: Check if version exists ---
    
    const versionPath = path.join(releasePath, 'versions', versionId);
    
    try {
      await fs.access(versionPath);
    } catch {
      return res.status(404).json({
        success: false,
        error: 'Version not found',
        message: `Version "${versionId}" not found for release "${releaseId}"`
      });
    }

    // --- STEP 4: Find the audio file ---
    
    const audioDir = path.join(versionPath, 'audio');
    const audioFiles = await fs.readdir(audioDir);
    
    if (audioFiles.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'Audio file missing',
        message: `No audio file found in ${versionId}/audio/`
      });
    }

    const audioFile = audioFiles[0];
    const audioPath = path.join(audioDir, audioFile);

    // --- STEP 5: Find the artwork file ---
    
    const artworkDir = path.join(releasePath, 'artwork');
    
    try {
      await fs.access(artworkDir);
    } catch {
      return res.status(404).json({
        success: false,
        error: 'Artwork missing',
        message: 'No artwork folder found. Upload artwork first.'
      });
    }

    const artworkFiles = await fs.readdir(artworkDir);
    
    if (artworkFiles.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'Artwork file missing',
        message: 'No artwork file found in artwork/ folder'
      });
    }

    const artworkFile = artworkFiles[0];
    const artworkPath = path.join(artworkDir, artworkFile);

    // --- STEP 6: Generate SoundCloud metadata text ---
    
    const versionName = metadata.versions?.[versionId]?.versionName || 
                       versionId.split('-').map(word => 
                         word.charAt(0).toUpperCase() + word.slice(1)
                       ).join(' ');
    
    const displayTitle = versionId === 'primary' 
      ? metadata.title
      : `${metadata.title} (${versionName})`;
    
    const releaseDate = new Date(metadata.releaseDate);
    const monthYear = releaseDate.toLocaleDateString('en-US', { 
      month: 'long', 
      year: 'numeric' 
    });
    
    const artistTag = metadata.artist.toLowerCase().replace(/\s+/g, '');
    const titleTag = metadata.title.toLowerCase().replace(/\s+/g, '');
    const genreTag = metadata.genre.toLowerCase().replace(/\s+/g, '').replace(/&/g, 'and');
    
    const metadataText = `Title: ${displayTitle}
Artist: ${metadata.artist}
Genre: ${metadata.genre}
Privacy: ${privacy.charAt(0).toUpperCase() + privacy.slice(1)}
Release Date: ${metadata.releaseDate}

Description:
${metadata.artist} - ${displayTitle}
Genre: ${metadata.genre}
Released: ${monthYear}

Follow ${metadata.artist}:
[Add your links here]

#electronicmusic #${genreTag} #newmusic #${artistTag} #${titleTag}`;

    // --- STEP 7: Create packages folder ---
    
    const packagesDir = path.join(releasePath, 'packages');
    
    try {
      await fs.mkdir(packagesDir, { recursive: true });
    } catch (error) {
      // Folder might already exist, that's okay
    }

    // --- STEP 8: Create the ZIP file ---
    
    const zipFileName = `soundcloud-${versionId}.zip`;
    const zipPath = path.join(packagesDir, zipFileName);
    
    try {
      await fs.unlink(zipPath);
      console.log(`   Deleted old package: ${zipFileName}`);
    } catch {
      // File doesn't exist, that's fine
    }

    console.log(`   Creating ZIP: ${zipFileName}`);

    const output = fsSync.createWriteStream(zipPath);
    const archive = archiver('zip', {
      zlib: { level: 9 }
    });

    const zipPromise = new Promise((resolve, reject) => {
      output.on('close', () => {
        console.log(`âœ… ZIP created: ${archive.pointer()} bytes`);
        resolve();
      });
      
      archive.on('error', (err) => {
        console.error(`âŒ ZIP creation failed: ${err.message}`);
        reject(err);
      });
    });

    archive.pipe(output);
    archive.file(audioPath, { name: audioFile });
    archive.file(artworkPath, { name: artworkFile });
    archive.append(metadataText, { name: 'soundcloud-metadata.txt' });
    await archive.finalize();
    await zipPromise;

    const stats = await fs.stat(zipPath);
    const fileSizeKB = (stats.size / 1024).toFixed(2);

    console.log(`ðŸ“¦ Package ready: ${zipFileName} (${fileSizeKB} KB)`);

    // --- STEP 9: Update distribution tracking ---
    
    if (!metadata.distribution) {
      metadata.distribution = {};
    }
    
    if (!metadata.distribution.publish) {
      metadata.distribution.publish = [];
    }

    const existingIndex = metadata.distribution.publish.findIndex(
      e => e.platform === 'SoundCloud' && e.versionId === versionId
    );

    const distributionEntry = {
      platform: 'SoundCloud',
      versionId: versionId,
      status: 'package_generated',
      privacy: privacy,
      packagePath: `packages/${zipFileName}`,
      generatedAt: new Date().toISOString()
    };

    if (existingIndex >= 0) {
      metadata.distribution.publish[existingIndex] = {
        ...metadata.distribution.publish[existingIndex],
        ...distributionEntry
      };
      console.log(`   Updated SoundCloud distribution tracking for ${versionId}`);
    } else {
      metadata.distribution.publish.push(distributionEntry);
      console.log(`   Added SoundCloud to distribution tracking for ${versionId}`);
    }

    await fs.writeFile(metadataPath, JSON.stringify(metadata, null, 2));

    // --- STEP 10: Success response ---
    
    res.json({
      success: true,
      message: `SoundCloud package generated for ${versionId}`,
      package: {
        fileName: zipFileName,
        path: zipPath,
        sizeKB: parseFloat(fileSizeKB),
        contents: [
          audioFile,
          artworkFile,
          'soundcloud-metadata.txt'
        ]
      },
      nextSteps: [
        '1. Download the ZIP file from the packages folder',
        '2. Go to SoundCloud and click Upload',
        `3. Upload the audio file (${audioFile})`,
        `4. Upload the artwork (${artworkFile})`,
        '5. Copy the metadata from soundcloud-metadata.txt and paste into SoundCloud fields',
        `6. Set privacy to: ${privacy}`
      ]
    });

  } catch (error) {
    console.error(`âŒ Error generating SoundCloud package:`, error.message);
    res.status(500).json({
      success: false,
      error: 'Failed to generate SoundCloud package',
      details: error.message
    });
  }
});

// --- 6h: Storage Status ---
// Reports disk space usage for the Releases drive.
// Warns if less than 10GB free (important with large WAV files ~50-100MB each).

app.get('/storage/status', async (req, res) => {
  try {
    const diskSpace = await checkDiskSpace(RELEASES_BASE);
    
    // Convert bytes to gigabytes for readability
    const totalGB = (diskSpace.size / (1024 ** 3)).toFixed(2);
    const freeGB = (diskSpace.free / (1024 ** 3)).toFixed(2);
    const usedGB = (totalGB - freeGB).toFixed(2);
    const usedPercent = ((usedGB / totalGB) * 100).toFixed(1);
    
    // Warning threshold: less than 10GB free
    const isLowSpace = diskSpace.free < (10 * 1024 ** 3);
    
    console.log(`ðŸ’¾ Disk space check: ${freeGB}GB free (${usedPercent}% used)`);
    
    res.json({
      disk: {
        totalGB: parseFloat(totalGB),
        usedGB: parseFloat(usedGB),
        freeGB: parseFloat(freeGB),
        usedPercent: parseFloat(usedPercent)
      },
      warning: isLowSpace ? 'Low disk space! Less than 10GB remaining.' : null,
      releasesPath: RELEASES_BASE
    });
    
  } catch (error) {
    console.error('âŒ Error checking disk space:', error);
    res.status(500).json({ error: 'Failed to check disk space' });
  }
});


// =============================================================================
// SECTION 7: ERROR HANDLER (Catch-all for unhandled errors)
// =============================================================================

app.use((err, req, res, next) => {
  res.status(err.statusCode || 500).json({
    success: false,
    message: err.message || 'Server error',
  });
});


// =============================================================================
// SECTION 8: START THE SERVER
// =============================================================================

app.listen(PORT, () => {
  console.log(`âœ… File-handler server running on port ${PORT}`);
});